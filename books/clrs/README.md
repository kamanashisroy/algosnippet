
Chapter 1 The role of algorithms in computing
==============================================

Chapter 2 Getting started
======================================

#### 2.1 Insertion sort

Exercise 2.1-4 


Chapter 3 Growth of functions
======================================


Chapter 4 Divide and Conquer
======================================

#### 4.1 Maximum subarray problem
#### 4.2 Strassen's algorithm for matrix multiplication
#### 4.3 The substitution method for solving recurrences
#### 4.4 The recursion-tree method for solving recurrences
#### 4.5 The master method for solving recurrences
#### 4.6 Proof of the master theorem

Chapter 5 Probabilistic Analysis and Randomized Algorithms
===========================================================

Chapter 6 Heapsort
======================================

#### 6.1 Heaps
#### 6.2 Maintaining the heap property
#### 6.3 Building a heap
#### 6.4 The heapsort algorithm
#### 6.5 Priority queues

Chapter 7 Quicksort
======================================

#### 7.1 Description of quicksort
#### 7.2 Performance of quicksort
#### 7.3 A randomized version of quicksort
#### 7.4 Analysis of quicksort

Chapter 8 Sorting in Linear Time
======================================

#### 8.1 Lower bounds for sorting
#### 8.2 Counting sort
#### 8.3 Radix sort
#### 8.4 Bucket sort

Chapter 9 Medians and Order statistics
=======================================

Chapter 10 Elementary data structures
=======================================

#### 10.1 Stacks and queues
#### 10.2 Linked Lists
#### 10.3 Implementing pointers and objects
#### 10.4 Representing rooted trees

Chapter 11 Hash Tables
======================================

#### 11.1 Direct-address tables

#### 11.2 Hash tables

#### 11.3 Hash functions

#### 11.4 Open addressing

#### 11.5 Perfect hashing

Chapter 12 Binary Search Trees
======================================

#### 12.1 12.2 12.3

#### 12.4 Randomly built binary search trees

Chapter 14 Augmenting data structures
======================================

Chapter 15 Dynamic Programming
======================================

#### 15.1 Rod Cutting

#### 15.2 Matrix-chain multiplication

#### 15.3 Elements of dynamic programming

Cost = `O(NUM_SUBPROBLEM*NUM_ENDEGREE_PER_SUBPROBLEM)`

When amortized,
Cost = `O(NUM_SUBPROBLEM + NUM_EDGES)`

#### 15.4 Longest common subsequence

#### 15.5 Optimal binary search trees

Chapter 16 Greedy Algorithm
=======================================

#### 16.1 An activity selection algirthm

#### 16.2 Elements of the greedy strategy

#### 16.3 Huffman codes

#### 16.4 Matroids and greedy methods

#### 16.5 A task-scheduling problem as a matroid

Chapter 17 Amortized Aanalysis
=======================================

#### 17.1 Aggregate analysis

#### 17.2 The accounting method

#### 17.3 The potential method

#### 17.4 Dynamic tables

Chapter 18 B trees
=======================================

Chapter 19 Fibonacci Heaps
=======================================

Chapter 20 Van Emde Boas Trees
=======================================

Chapter 21 Data structures for disjoint sets
=============================================

#### 21.1 Disjoint-set operations
#### 21.2 Linked-list representation of disjoint sets
#### 21.3 Disjoint-set forests
#### 21.4 Analysis of union by rank with path compression

Chapter 22 Elementary Graph Algorithms
============================================

#### 22.1 Representations of graphs
#### 22.2 Breadth-first search
#### 22.3 Depth-first search
#### 22.4 Topological sort
#### 22.5 Strongly connected components

Chapter 23 Minimum Spanning Trees
============================================

#### 23.1 Growing a minimum spanning tree
#### 23.2 The algorithms of Kruskal and Prim

Chapter 24 Single-source shortest path
============================================

#### 24.1 Bellman-Ford algorithm
#### 24.2 Single source shortest paths 
#### 24.3 Dijkstra's algorithm
#### 24.4 Difference constraints and shortest paths
#### 24.5 Proofs of shortest-path properties

Chapter 25 All-pairs shortest paths
============================================

#### 25.1 Shortest paths and matrix multiplication
#### 25.2 The Floyd-Warshall algorithms
#### 25.3 Johnson's algorithm for sparse graphs

Chapter 26 Maximum Flow
============================================

#### 26.1 Flow networks
#### 26.2 The ford Fulkerson method
#### 26.3 Maximum bipartite matching
#### 26.4 Push-relabel algorithms
#### 26.4 The relabel to front algorithm

Chapter 27 Multithreaded algorithms
============================================

#### 27.1 The basics of dynamic multithreading
#### 27.2 Multithreaded matrix multiplication
#### 27.3 Multithreaded merge sort

Chapter 28 Matrix operations
============================================

#### 28.1 Solving systems of linear equations
#### 28.2 Inverting matrix
#### 28.3 Symmetric positive-definite matrices and least-square approximation

Chapter 29 linear programming
============================================

Chapter 30 Polynomial and FFT
============================================

Chapter 31 Number-theoretic algorithms
============================================

#### 31.1 Elementary number-theoretic notions
#### 31.2 Greatest common divisor
#### 31.3 Modular arithmetic
#### 31.4 Solving modular linear equations
#### 31.5 The Chinese remainder theorem
#### 31.6 Powers of an element
#### 31.7 The RSA public-key cryptosystem
#### 31.8 Primality testing
#### 31.9 Integer factorization

Chapter 32 String matching
=============================================

#### 32.1 The naive string-matching algorithm
#### 32.2 The Rabin-Karp algorithm
#### 32.3 String matching with finite automata
#### 32.4 The Knuth-Morris-Pratt algorithm

Chapter 33 Computational Geometry
=============================================

#### 33.1 Line-segment properties
#### 33.2 Determining whether any pair of segment intersects
#### 33.3 Finding the convex hull
#### 33.4 Finding the closest pair of points

